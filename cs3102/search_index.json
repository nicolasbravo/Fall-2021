[["intro.html", "Week 11 Notes CS 3102 1 Intro", " Week 11 Notes CS 3102 Nico Bravo 1 Intro Limits of what Turing machines can or cannot do are difficult to determine This week, demonstrate uncomputable with reductions Find uncomputable functions, then use those to find more uncomputable functions Rice’s theorem Clear statement dividing what is and is not computable "],["decidable-recognizable-computable.html", "2 Decidable, Recognizable, Computable", " 2 Decidable, Recognizable, Computable Description of a turing machine \\(U (M,w)\\) \\(U\\) = universal machine \\(M\\) = machine \\(w\\) = input States, transitions, etc “Idealized Python” code of the machine A language is decidable iff it is exactly the set of strings accepted by some always-halting TM \\(M\\) must always halt on every input Things not in the language either Reject and halt or Run forever Generally, computable = decideable "],["an-undecidable-problem.html", "3 An Undecidable Problem", " 3 An Undecidable Problem Acceptance Problem/Language Given a TM description \\(M\\) and a string \\(w\\), does \\(M\\) accept input \\(w\\)? \\(A_{TM} (M,w) = \\{ (M,w)|M(w)\\) accepts\\(\\}\\) Undecidable The paradox we discussed last week "],["proof-by-reduction.html", "4 Proof by Reduction 4.1 Proof of Impossibility by Reduction", " 4 Proof by Reduction Proving other languages undecidable using reduction Convert some problem into a known undecidable one to show it’s undecidable Prove something is undecideable by relating it to a function we already know is undecidable Show how two different problems relate to each other One problem reduces to another problem Make sure that the order is correct (\\(A\\) reduces to \\(B\\), not the other way around) Transformations must use only things you can do 4.1 Proof of Impossibility by Reduction Have a problem \\(X\\) that we know is impossibly difficult \\(X\\) is some TM that decides \\(A_{TM}\\) Have a problem \\(Y\\) that we assume is possible \\(Y\\) is some TM that decides problem \\(B\\) (the halting problem) Show how to use \\(Y\\) to perform \\(X\\) Use program to halt to compute accepts \\(X\\) isn’t possible, but \\(Y\\) could be used to perform \\(X\\) Nothing allows us to calculate accepts …but we could use halting problem to calculate accepts Therefore halt is impossible to solve Conclusion: \\(Y\\) must not be possible either "],["halts-is-undecidable.html", "5 HALTS is Undecidable 5.1 Deciding \\(A_{TM}\\) with \\(HALT_{TM}\\)", " 5 HALTS is Undecidable \\(A_{TM} = \\{(M,w)|M\\) is a TM description and \\(M\\) accepts input \\(w\\}\\) \\(HALT_{TM} = \\{(M,w) | M\\) is a TM description and \\(M\\) halts on input \\(w\\}\\) All machine description input pairs in which the machine halts on input Every \\((M,w)\\) which halts at all belongs to \\(HALT_{TM}\\) \\((M,w)\\) belongs to \\(A_{TM}\\) if it both halts and accepts \\(A_{TM} \\subseteq HALT_{TM}\\) To show \\(HALT_{TM}\\) is undecidable, show \\(A_{TM}\\) isn’t harder than \\(HALT_{TM}\\) Want to use a solver for \\(HALT_{TM}\\) to build a solver for \\(A_{TM}\\) If \\(HALT\\) was possible, use it to solve the impossible (\\(A\\)) \\(A_{TM}\\) reduces to \\(HALT_{TM}\\) 5.1 Deciding \\(A_{TM}\\) with \\(HALT_{TM}\\) Assume \\(HALT_{TM}\\) id decidable Then some TM \\(R\\) can decide \\(HALT_{TM}\\) We can use \\(R\\) to build a machine \\(D\\) that decides \\(A_{TM}\\) A machine that takes in \\(M\\) and \\(w\\) as input pair and return yes or no We want \\(R\\) such that does \\(M(w)\\) halt, to be able to then solve \\(D\\) If \\(R\\) = no, then \\(D\\) = no If \\(R\\) = yes, then we solve for \\(D\\) with \\(M(w)\\) to get yes or no Any TM that decidse \\(HALT\\) could therefore solve \\(A\\) "],["finite-is-undecidable.html", "6 Finite is Undecidable 6.1 Another example: \\(Finite_{TM}\\) 6.2 \\(Finite_{TM} \\geq HALT_{TM}\\) 6.3 Pseudocode for \\(M&#39;\\)", " 6 Finite is Undecidable Is the language of some Turing machine a finite language? 6.1 Another example: \\(Finite_{TM}\\) Noncomputable function! \\(Finite_{TM} = \\{M|L(M)\\) is finite\\(\\}\\) Machine \\(M\\) Return true if the number of things the machine accepts is finite Return false if infinite How do we show that \\(Finite_{TM}\\) is undecidable? Reduce some language we already know is undecidable to \\(Finite_{TM}\\) Use \\(Finite_{TM}\\) to solve \\(HALT_{TM}\\) 6.2 \\(Finite_{TM} \\geq HALT_{TM}\\) Given some instance of \\(HALT_{TM}\\), create a Turing machine \\(M&#39;\\) whose language is \\(\\emptyset\\) iff \\(M(w)\\) halts Reduce \\(HALT_{TM}\\) to \\(Finite_{TM}\\) If we know whether or not \\(L(M&#39;)\\) is \\(\\emptyset\\), we know whether or not \\(M(w)\\) halts 6.3 Pseudocode for \\(M&#39;\\) We want to define but never run mPrime(x) where x is some input we don’t care about. It simulates the Turing machine \\(M\\) with input \\(w\\), the two parameters also given to Halt. def mPrime(x): y = M(w) return True def Halt(M,w): #mPrime = string resulted from making M into M&#39; mPrime = make_mPrime(M,w) #if finite were to exist, we could invoke here return finite(mPrime) In this case, the function called to make \\(M&#39;\\) (mPrime(x)) would either Run forever, as it is stuck in a loop and whatever was provided in x would have never returned been accepted. In this case, the language of \\(M&#39;\\) would be “none” strings, or the empty set of strings \\(\\emptyset\\). Halt \\(M(w)\\), as no matter what input would be provided in x, the machine would accept. In this case, the language of \\(M&#39;\\) would be all possible strings. Essentially, to know whether \\(M(w)\\) would halt, we would have to have Halt work. "],["prints3-and-ismalware-are-undecidable.html", "7 Prints3 and IsMalware are Undecidable 7.1 Prints3 7.2 IsMalware", " 7 Prints3 and IsMalware are Undecidable 7.1 Prints3 Imagine we want to know whether a Python program prints 3. \\[ Prints3(M,w) = \\left\\{\\begin{array}{ll} 1 &amp; \\text{if } M(w) \\text{ prints 3}\\\\ 0 &amp; \\text{otherwise} \\end{array}\\right. \\] This is undecidable, and to show this, we are going to use \\(Prints3\\) to solve \\(HALT\\). This will reduce \\(HALT\\) to \\(Print3\\). We are going to construct a python function \\(M&#39;\\) such that \\(M&#39;\\) prints 3 iff \\(M(w)\\) halts. 7.1.1 Pseudocode for Prints3 def mPrime(x): #assume our universal Turing machine #doesn&#39;t print 3 y = M(w) print(3) Now, we know for certain that if \\(M(w)\\) halts, we definitely print 3. If \\(M(w)\\) runs forever, we never print 3 as the line y = M(w) never lets us print 3. 7.2 IsMalware Imagine we want to know whether a Python program is malware (it does a bad thing). \\[ Malware(M) = \\left\\{\\begin{array}{ll} 1 &amp; \\text{if } M \\text{ is Malware}\\\\ 0 &amp; \\text{otherwise} \\end{array}\\right. \\] This is undecidable, and like with \\(Print3\\), we want to reduce \\(HALT\\) to \\(Malware\\). To do that, we are going to build an \\(M&#39;\\) such that \\(M&#39;\\) is Malware iff \\(M(w)\\) halts. 7.2.1 Pseudocode for Prints3 This is going to be very similar to what we did before def mPrime(x): #assume M(w) does NOT do a bad thing y = M(w) #do a bad thing badThing(x) Now we know that if \\(M(w)\\) halts, the program will have malware, but if it goes on forever, it does not. "],["rices-theorem.html", "8 Rice’s Theorem 8.1 NoEven is undecidable 8.2 Semantic Properties 8.3 Rice’s Theorem", " 8 Rice’s Theorem 8.1 NoEven is undecidable \\(NoEven = \\{M|M\\) describes a Turing machine that accepts only odd numbers\\(\\}\\) \\(F_{NoEven}(M) = 1\\) if \\(M\\) is a Turing machine that accepts only odd numbers We want to build a machine \\(M&#39;\\) such that if it were to receive an input \\(x\\), then whenever \\(x\\) is even, then \\(x\\) was not in the language of the machine \\(M&#39;\\). This is only the case when \\(M\\) halts on \\(w\\). 8.1.1 Pseudocode for NoEven Let \\(M_{True}\\) be a Turing machine that accepts an even input. Because \\(\\emptyset\\) does not have the property \\(NoEven\\), we want to check if it is even instead, then give the opposite result (as \\(M_{True} \\notin NoEven\\)). def mPrime(x): y = False #run M(w) #if stuck in loop: False #if continues, not False M(w) y = M_True(x) return not y Not NoEven is undecidable. 8.2 Semantic Properties Two machines \\(M,M&#39;\\) are functionally equivalent if \\(\\forall x \\in \\{0,1\\}^*,M(x) = M&#39;(x)\\) A function \\(F:\\{0,1\\}^* \\rightarrow \\{0,1\\}\\) is semantic if for every pair of functionally equivalent Turing Machines \\(M,M&#39;,F(M) = F(M&#39;)\\) Essentially: a semantic property is a property of the function/language of the machine, not the behavior If we ask the property for a return value for two equivalent machines, it will give the same answer 8.3 Rice’s Theorem Rice’s Theorem says that we have a shortcut for semantic properties. If \\(F\\) is a semantic property, then either \\(F\\) is not computable or \\(F\\) is trivial Apply to no Turing machines: \\(F(M) = 0\\) Apply to all Turing machines: \\(F(M) = 1\\) Either return yes, no, or no answer 8.3.1 Pattern for Semantic Properties \\(P_{TM} = \\{M|M\\) describes a Turing machine whose language satisfies \\(P\\}\\) Use a decider for \\(P_{TM}\\) to decide \\(HALT\\): reduce \\(HALT\\) to \\(P_{TM}\\) For any given \\(M,w\\) pair, define \\(M&#39;\\) such that on input \\(x\\), \\(L(M)\\) (language) has property \\(P\\) iff \\(M(w)\\) halts. 8.3.2 Pseudocode for \\(P_{TM}\\) Assume \\(M_{True}\\) is a Turing machine that accepts strings to make a language with property \\(P\\) (property \\(P\\) exists). def mPrime(x): y = False M(w) y = M_True(x) return y We are showing that if \\(M(w)\\) halts, the language of \\(M&#39;\\) would be equal to the language of \\(M_{True}\\). If \\(M(w)\\) were to run forever, then the language of \\(M&#39;\\) would be none (the empty set \\(\\emptyset\\)). If \\(P\\) is not trivial and the empty language doesn’t have property \\(P\\), then \\(M&#39;\\) has property \\(P\\) iff \\(M(w)\\) halted. 8.3.3 Semantic Questions If a question (on an exam, for example) were semantic, we could first check to see if it is one of two expections (where the property is trivial) and the answer is either always yes or always no. Else, it is not a decidable question. If it not a semantic question (“does it print 3?”), then Rice’s Theorem does not apply. Let’s say that a question is asked on an exam about Turing machines. How would we solve it? Is this a semantic property? (is this a computable property?) If yes: is it trivial? (does it apply to all or none Turing machines?) Undecidable. You have to do a reduction. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
